---
title: "Raw checker"
output: html_document

params:
  projectName:
    label: "Name of the report"
    value: "Mock"
    input: text
  dirRaw:
    label: "Working directory"
    value: "Type direcotry for standalone script"
    input: text
  dirOut:
    label: "Output directory"
    value: "Type output directory for standalone script"
    input: text
  infile:
    label: "Experiment file"
    value: "Location and metafile"
    input: file
  priFor:
    label: "Forward primer"
    value: "CACGGTCGKCGGCGCCATT"
    input: text
  priRev:
    label: "Reverse primer"
    value: "GGACTACHVGGGTWTCTAAT"
    input: text

---


```{r setup0, echo = FALSE}

knitr::opts_chunk$set(echo = FALSE, fig.align="center")

```


```{r reproduce}

## Change to FALSE if you ran the analysis and only want to produce the report again
firstRun0 <- TRUE
```


```{r paramDirsCheck, child = "conditions/0dirCheck.Rmd"}

```


```{r rawcheckParams}

## Check experimental file from main script
## If the parameter is empty turns on standalone settings
if (is.null(params$data)) {

  ## Check the existence of experimental file
  if (file.exists(params$infile)) {

    ## Set file to variable
    expFile <- params$infile
    ## Use experiment file in specific chunk
    experiOn = TRUE
  }
} else {
  ## Use experimental file from main script
  expFile <- experimentFile

  if (file.exists(expFile)) {

    ## No experiment file as input
    experiOn = TRUE
  }
} 

## Check primers from main script
## If either are not null
if (!is.null(params$primerFor) | !is.null(params$primerFor)){

  ## If both primers are not empty
  if (params$primerFor != '' && params$primerRev != ''){

    ## Both primers found on main script
    FWD <- primerForward
    REV <- primerReverse
    primerFound <- TRUE
  } else {

    ## Main script has no primers
    primerFound <- FALSE
  }
} else {

  ## No main script
  FWD <- params$priFor
  REV <- params$priRev

  if (FWD != '' && REV != ''){

    ## Standalone primers
    primerFound <- TRUE
  } else {
 
    ## No stanalone primers
    primerFound <- FALSE
  }
}

```


```{r lib0, include = FALSE}

library("ShortRead")
library("dada2")
library("tidyverse")
library("knitr")

start_time <- Sys.time()

```


```{r rerunFilesDetect, eval = (!firstRun0)}
# Condition triggers on rerun only
# Check if metafile exists, rename

if (file.exists(file.path(reportDir,"metafile.csv"))){
  
  ## Rename meta to oldmeta
  file.copy(file.path(reportDir,"metafile.csv"), file.path(reportDir,"old_metafile.csv"))
  oldMeta <- read.csv(file.path(reportDir,"old_metafile.csv"), row.names=1)
  foundSamples <- oldMeta[oldMeta$Status=="Found","Samples"]

  missingRaw <- oldMeta[oldMeta$Status=="Missing","Samples"]
  if (type(missingRaw)=="integer"){
    missingRaw <- as.character(missingRaw)
  }
} else {

  ## If no metafile found then run first time
  firstRun0=TRUE
}

```

```{r fastqDirCheck`, eval = firstRun0}

## Match _R1 with forward fastq files
fnFs <- sort(intersect(list.files(pathRaw, pattern="_R1", full.names = TRUE), list.files(pathRaw, pattern="fastq", full.names = TRUE)))

samples.forward <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)

## Reverse files
fnRs <- sort(intersect(list.files(pathRaw, pattern="_R2", full.names = TRUE), list.files(pathRaw, pattern="fastq", full.names = TRUE)))

samples.reverse <- sapply(strsplit(basename(fnRs), "_"), `[`, 1)

## Common sample names
sample.names <- intersect(samples.forward,samples.reverse)

## Check if there are any fastq
if (length(sample.names) == 0){

  print ("No fastq files found. Please provide a correct directory.")
  knitr::knit_exit()
}

```


```{r matchFastq, eval = firstRun0}

## Match Samples with actual found samples
metaSamples <- metaInfo$Samples

# If raw file is number convert to character
if (type(metaSamples)=="integer"){
  metaSamples <- as.character(metaSamples)
}

foundSamples <- intersect(metaSamples,sample.names)

## raw fastq vs names on metafile eg: setdiff(metaSamples,sample.names)
## metafile vs raw fastq eg: setdiff(sample.names,metaSamples)
## Both diff c(setdiff(metaSamples,sample.names), setdiff(sample.names,metaSamples))

missingRaw <- setdiff(metaSamples,sample.names)

```


```{r updateMetaFile}

## df of found samples
analyseSamples <- data.frame(Samples = foundSamples, Status = "Found")

## missing raw is empty
if (identical(missingRaw, character(0))){

  finalStatus <- analyseSamples
} else {

  missingSamples <- data.frame(Samples = missingRaw, Status = "Missing")
  finalStatus <- rbind(analyseSamples, missingSamples)
}

metaFinal <- merge(x=metaInfo, y=finalStatus, by="Samples",all=TRUE)

## Detect and remove empty columns
emptycols <- sapply(metaFinal, function (k) all(is.na(k)))
metaFinal <- metaFinal[!emptycols]

write.csv(metaFinal, file.path(reportDir,"metafile.csv"))

```


## Raw analysis


In the `r basename(rawDir)` folder, there were `r length(sample.names)` fastq pairs found.
Only, samples with the corresponding pair are anaylized.
Based on the metafile, a total of `r length(foundSamples)` samples were detected. Missing samples `r if (identical(missingRaw, character(0))){ "0" } else {length(missingRaw)}`.
The metafile used for the run can be downloaded `r xfun::embed_file( file.path(reportDir,"metafile.csv"), text = "Here !")`  


Visualizing the quality profiles of the first two forward and reverse reads.


```{r rawQuality, eval = firstRun0, include = FALSE}

## Import final files csv
runFiles <- read.csv(file.path(reportDir,"metafile.csv"), row.names = 1)
runFound <- runFiles[runFiles$Status=="Found",]

## First found sample
firstRaw <- head(runFound$Samples,1)
if (type(firstRaw)=="integer"){
  firstRaw <- as.character(firstRaw)
}

## Detect the first pair for figure
samPairFig <- list.files(rawDir, pattern=firstRaw, full.names = TRUE)
readsRaw <- plotQualityProfile(samPairFig[1:2])

ggsave(file.path(reportDir,"rawReads.png"), readsRaw, device="png")

```

```{r firstRaw, fig.cap = "Raw quality of the first pair"}

knitr::include_graphics(file.path(reportDir, "rawReads.png"))

```


In gray-scale is a heat map of the frequency of each quality score at each base position. The mean quality score at each position is shown by the green line. The quartiles of the quality score distribution by the orange lines. The red line shows the scaled proportion of reads that extend to at least that position.


```{r nFilter, eval=firstRun0}

readtrack <- data.frame(matrix(nrow = nrow(runFound), ncol = 2))

nOut <- file.path(reportDir, "nFilter")
if(!dir.exists(nOut)) dir.create(nOut)

for (i in 1:nrow(runFound)){

  ## Sample names
  sampName <- runFound$Samples[i]
  #print (sampName)

  ## Identify forward and reverse reads
  fnF <- intersect(list.files(pathRaw, pattern = paste0(sampName,"_"), full.names = TRUE), list.files(pathRaw, pattern = "_R1", full.names = TRUE))
  fnR <- intersect(list.files(pathRaw, pattern = paste0(sampName,"_"), full.names = TRUE), list.files(pathRaw, pattern = "_R2", full.names = TRUE))

  ## Name of filtered reads
  nFiltF <- file.path(nOut, paste0(sampName, "_R1_filtN.fastq.gz"))
  nFiltR <- file.path(nOut, paste0(sampName, "_R2_filtN.fastq.gz"))
  ## names function to set name of an object
  names(nFiltF) <- sampName
  names(nFiltR) <- sampName 

  outN <- filterAndTrim(fnF, nFiltF, fnR, nFiltR, maxN = 0, matchIDs=TRUE, multithread = TRUE)
  readtrack[i,1:2] <- outN[1:2]
}

## For checking
colnames(readtrack) <- c("raw","nRemoval")
readtrack$Samples <- runFound$Samples
write.csv(readtrack, file.path(reportDir,"readtrackRawN.csv"))

```


```{r noPrimerCheck}

if (firstRun0=="FALSE") {

  primerFound <- FALSE
}
```


```{r primerCheck, child = if (primerFound) "conditions/0primersCheck.Rmd"}

```


```{r endTime0}

end_time <- Sys.time()
end_time - start_time

```
